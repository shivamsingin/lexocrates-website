const crypto = require('crypto');
const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');

const execAsync = promisify(exec);

class MalwareScanner {
  constructor() {
    this.suspiciousPatterns = [
      // Executable patterns
      /\.exe$/i,
      /\.bat$/i,
      /\.cmd$/i,
      /\.com$/i,
      /\.scr$/i,
      /\.pif$/i,
      /\.vbs$/i,
      /\.js$/i,
      /\.jar$/i,
      /\.msi$/i,
      /\.dll$/i,
      /\.sys$/i,
      
      // Archive patterns that might contain executables
      /\.zip$/i,
      /\.rar$/i,
      /\.7z$/i,
      /\.tar$/i,
      /\.gz$/i,
      /\.bz2$/i,
      
      // Script patterns
      /\.ps1$/i,
      /\.py$/i,
      /\.php$/i,
      /\.asp$/i,
      /\.aspx$/i,
      /\.jsp$/i,
      /\.pl$/i,
      /\.sh$/i,
      /\.bash$/i,
      /\.csh$/i,
      /\.ksh$/i,
      /\.tcsh$/i,
      /\.zsh$/i
    ];

    this.dangerousExtensions = [
      '.exe', '.bat', '.cmd', '.com', '.scr', '.pif', '.vbs', '.js',
      '.jar', '.msi', '.dll', '.sys', '.ps1', '.py', '.php', '.asp',
      '.aspx', '.jsp', '.pl', '.sh', '.bash', '.csh', '.ksh', '.tcsh', '.zsh'
    ];

    this.suspiciousHeaders = [
      // PE (Portable Executable) header
      '4D5A', // MZ
      // ELF header
      '7F454C46', // ELF
      // Mach-O header
      'FEEDFACE', // Mach-O
      'FEEDFACF', // Mach-O 64-bit
      // Script shebangs
      '2321', // #!
      // HTML with script tags
      '3C68746D6C', // <html
      '3C736372697074', // <script
      // Office documents with macros
      '504B0304', // ZIP (Office documents)
      'D0CF11E0' // OLE (Legacy Office documents)
    ];

    this.maxFileSize = 100 * 1024 * 1024; // 100MB
    this.scanTimeout = 30000; // 30 seconds
  }

  /**
   * Scan file for malware and security threats
   */
  async scanFile(filePath, fileBuffer = null) {
    try {
      const scanResult = {
        filePath: filePath,
        fileName: path.basename(filePath),
        scanTime: new Date().toISOString(),
        isClean: true,
        threats: [],
        warnings: [],
        scanDetails: {}
      };

      // Get file info
      const fileInfo = await this.getFileInfo(filePath, fileBuffer);
      scanResult.fileInfo = fileInfo;

      // Check file size
      if (fileInfo.size > this.maxFileSize) {
        scanResult.warnings.push(`File size (${fileInfo.size} bytes) exceeds maximum allowed size`);
      }

      // Check file extension
      const extensionCheck = this.checkFileExtension(fileInfo.extension);
      if (!extensionCheck.isAllowed) {
        scanResult.threats.push(`File extension '${fileInfo.extension}' is not allowed`);
        scanResult.isClean = false;
      }

      // Check file headers
      const headerCheck = await this.checkFileHeaders(filePath, fileBuffer);
      if (headerCheck.suspicious) {
        scanResult.threats.push(`Suspicious file headers detected: ${headerCheck.reason}`);
        scanResult.isClean = false;
      }

      // Check file content patterns
      const contentCheck = await this.checkFileContent(filePath, fileBuffer);
      if (contentCheck.suspicious) {
        scanResult.threats.push(`Suspicious content patterns detected: ${contentCheck.reason}`);
        scanResult.isClean = false;
      }

      // Calculate file hash
      const fileHash = await this.calculateFileHash(filePath, fileBuffer);
      scanResult.fileHash = fileHash;

      // Check against known malicious hashes (simulated)
      const hashCheck = await this.checkKnownHashes(fileHash);
      if (hashCheck.isKnownMalicious) {
        scanResult.threats.push(`File hash matches known malicious file: ${hashCheck.reason}`);
        scanResult.isClean = false;
      }

      // Perform deep scan if needed
      if (this.shouldPerformDeepScan(fileInfo)) {
        const deepScanResult = await this.performDeepScan(filePath, fileBuffer);
        scanResult.deepScan = deepScanResult;
        
        if (deepScanResult.threats && deepScanResult.threats.length > 0) {
          scanResult.threats.push(...deepScanResult.threats);
          scanResult.isClean = false;
        }
      }

      // Check for embedded objects
      const embeddedCheck = await this.checkEmbeddedObjects(filePath, fileBuffer);
      if (embeddedCheck.hasEmbeddedObjects) {
        scanResult.warnings.push(`File contains embedded objects: ${embeddedCheck.objects.join(', ')}`);
      }

      // Final assessment
      scanResult.assessment = this.generateAssessment(scanResult);
      scanResult.recommendation = this.generateRecommendation(scanResult);

      return scanResult;
    } catch (error) {
      console.error('Malware scan error:', error);
      return {
        filePath: filePath,
        scanTime: new Date().toISOString(),
        isClean: false,
        threats: [`Scan failed: ${error.message}`],
        warnings: [],
        error: error.message
      };
    }
  }

  /**
   * Get file information
   */
  async getFileInfo(filePath, fileBuffer = null) {
    const stats = fileBuffer ? 
      { size: fileBuffer.length } : 
      await fs.stat(filePath);

    return {
      name: path.basename(filePath),
      extension: path.extname(filePath).toLowerCase(),
      size: stats.size,
      mimeType: this.getMimeType(filePath),
      lastModified: stats.mtime || new Date()
    };
  }

  /**
   * Check if file extension is allowed
   */
  checkFileExtension(extension) {
    const isDangerous = this.dangerousExtensions.includes(extension);
    const isSuspicious = this.suspiciousPatterns.some(pattern => pattern.test(extension));

    return {
      isAllowed: !isDangerous,
      isSuspicious: isSuspicious,
      riskLevel: isDangerous ? 'high' : isSuspicious ? 'medium' : 'low'
    };
  }

  /**
   * Check file headers for suspicious patterns
   */
  async checkFileHeaders(filePath, fileBuffer = null) {
    try {
      let buffer;
      if (fileBuffer) {
        buffer = fileBuffer;
      } else {
        buffer = await fs.readFile(filePath);
      }

      const header = buffer.slice(0, 16).toString('hex').toUpperCase();
      
      for (const suspiciousHeader of this.suspiciousHeaders) {
        if (header.startsWith(suspiciousHeader)) {
          return {
            suspicious: true,
            reason: `Matches suspicious header pattern: ${suspiciousHeader}`,
            detectedHeader: header
          };
        }
      }

      return { suspicious: false };
    } catch (error) {
      console.error('Header check error:', error);
      return { suspicious: false, error: error.message };
    }
  }

  /**
   * Check file content for suspicious patterns
   */
  async checkFileContent(filePath, fileBuffer = null) {
    try {
      let buffer;
      if (fileBuffer) {
        buffer = fileBuffer;
      } else {
        buffer = await fs.readFile(filePath);
      }

      const content = buffer.toString('utf8', 0, Math.min(buffer.length, 10000));
      
      const suspiciousPatterns = [
        /<script\b[^>]*>/i,
        /javascript:/i,
        /vbscript:/i,
        /onload\s*=/i,
        /onerror\s*=/i,
        /eval\s*\(/i,
        /document\.write/i,
        /window\.open/i,
        /ActiveXObject/i,
        /WScript\.Shell/i,
        /cmd\.exe/i,
        /powershell/i,
        /exec\s*\(/i,
        /system\s*\(/i,
        /shell_exec/i,
        /passthru/i
      ];

      for (const pattern of suspiciousPatterns) {
        if (pattern.test(content)) {
          return {
            suspicious: true,
            reason: `Contains suspicious pattern: ${pattern.source}`,
            pattern: pattern.source
          };
        }
      }

      return { suspicious: false };
    } catch (error) {
      console.error('Content check error:', error);
      return { suspicious: false, error: error.message };
    }
  }

  /**
   * Calculate file hash
   */
  async calculateFileHash(filePath, fileBuffer = null) {
    try {
      let buffer;
      if (fileBuffer) {
        buffer = fileBuffer;
      } else {
        buffer = await fs.readFile(filePath);
      }

      const md5 = crypto.createHash('md5').update(buffer).digest('hex');
      const sha1 = crypto.createHash('sha1').update(buffer).digest('hex');
      const sha256 = crypto.createHash('sha256').update(buffer).digest('hex');

      return { md5, sha1, sha256 };
    } catch (error) {
      console.error('Hash calculation error:', error);
      throw error;
    }
  }

  /**
   * Check against known malicious hashes (simulated)
   */
  async checkKnownHashes(fileHash) {
    // In a real implementation, this would check against a database of known malicious hashes
    const knownMaliciousHashes = [
      // Example malicious hashes (these are fake for demonstration)
      'd41d8cd98f00b204e9800998ecf8427e', // MD5
      'da39a3ee5e6b4b0d3255bfef95601890afd80709', // SHA1
      'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855' // SHA256
    ];

    const isKnownMalicious = knownMaliciousHashes.includes(fileHash.md5) ||
                            knownMaliciousHashes.includes(fileHash.sha1) ||
                            knownMaliciousHashes.includes(fileHash.sha256);

    return {
      isKnownMalicious,
      reason: isKnownMalicious ? 'Hash matches known malicious file database' : null
    };
  }

  /**
   * Determine if deep scan is needed
   */
  shouldPerformDeepScan(fileInfo) {
    return fileInfo.size > 1024 * 1024 || // Files larger than 1MB
           fileInfo.extension === '.zip' ||
           fileInfo.extension === '.rar' ||
           fileInfo.extension === '.7z' ||
           fileInfo.extension === '.pdf' ||
           fileInfo.extension === '.doc' ||
           fileInfo.extension === '.docx';
  }

  /**
   * Perform deep scan of file
   */
  async performDeepScan(filePath, fileBuffer = null) {
    try {
      const deepScanResult = {
        threats: [],
        warnings: [],
        scanTime: Date.now()
      };

      // Check for embedded executables in archives
      if (this.isArchiveFile(filePath)) {
        const archiveScan = await this.scanArchive(filePath, fileBuffer);
        if (archiveScan.threats) {
          deepScanResult.threats.push(...archiveScan.threats);
        }
        if (archiveScan.warnings) {
          deepScanResult.warnings.push(...archiveScan.warnings);
        }
      }

      // Check for macro content in Office documents
      if (this.isOfficeDocument(filePath)) {
        const macroScan = await this.scanForMacros(filePath, fileBuffer);
        if (macroScan.hasMacros) {
          deepScanResult.warnings.push('Document contains macros');
        }
      }

      // Check for embedded JavaScript in PDFs
      if (this.isPDFDocument(filePath)) {
        const pdfScan = await this.scanPDF(filePath, fileBuffer);
        if (pdfScan.hasJavaScript) {
          deepScanResult.warnings.push('PDF contains embedded JavaScript');
        }
      }

      return deepScanResult;
    } catch (error) {
      console.error('Deep scan error:', error);
      return {
        threats: [`Deep scan failed: ${error.message}`],
        warnings: [],
        error: error.message
      };
    }
  }

  /**
   * Check for embedded objects
   */
  async checkEmbeddedObjects(filePath, fileBuffer = null) {
    try {
      let buffer;
      if (fileBuffer) {
        buffer = fileBuffer;
      } else {
        buffer = await fs.readFile(filePath);
      }

      const content = buffer.toString('utf8', 0, Math.min(buffer.length, 50000));
      
      const embeddedObjects = [];
      
      // Check for embedded images
      if (/<img\b[^>]*>/i.test(content)) {
        embeddedObjects.push('images');
      }
      
      // Check for embedded scripts
      if (/<script\b[^>]*>/i.test(content)) {
        embeddedObjects.push('scripts');
      }
      
      // Check for embedded objects
      if (/<object\b[^>]*>/i.test(content)) {
        embeddedObjects.push('objects');
      }
      
      // Check for embedded iframes
      if (/<iframe\b[^>]*>/i.test(content)) {
        embeddedObjects.push('iframes');
      }

      return {
        hasEmbeddedObjects: embeddedObjects.length > 0,
        objects: embeddedObjects
      };
    } catch (error) {
      console.error('Embedded objects check error:', error);
      return { hasEmbeddedObjects: false, error: error.message };
    }
  }

  /**
   * Check if file is an archive
   */
  isArchiveFile(filePath) {
    const archiveExtensions = ['.zip', '.rar', '.7z', '.tar', '.gz', '.bz2'];
    return archiveExtensions.includes(path.extname(filePath).toLowerCase());
  }

  /**
   * Check if file is an Office document
   */
  isOfficeDocument(filePath) {
    const officeExtensions = ['.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx'];
    return officeExtensions.includes(path.extname(filePath).toLowerCase());
  }

  /**
   * Check if file is a PDF document
   */
  isPDFDocument(filePath) {
    return path.extname(filePath).toLowerCase() === '.pdf';
  }

  /**
   * Scan archive files for embedded executables
   */
  async scanArchive(filePath, fileBuffer = null) {
    // This is a simplified implementation
    // In production, you would use a library like 'unzipper' or 'extract-zip'
    return {
      threats: [],
      warnings: ['Archive scanning requires additional libraries']
    };
  }

  /**
   * Scan for macros in Office documents
   */
  async scanForMacros(filePath, fileBuffer = null) {
    // This is a simplified implementation
    // In production, you would use a library like 'mammoth' or 'officegen'
    return {
      hasMacros: false,
      warnings: ['Macro scanning requires additional libraries']
    };
  }

  /**
   * Scan PDF for embedded JavaScript
   */
  async scanPDF(filePath, fileBuffer = null) {
    // This is a simplified implementation
    // In production, you would use a library like 'pdf-parse'
    return {
      hasJavaScript: false,
      warnings: ['PDF scanning requires additional libraries']
    };
  }

  /**
   * Get MIME type
   */
  getMimeType(filePath) {
    const ext = path.extname(filePath).toLowerCase();
    const mimeTypes = {
      '.pdf': 'application/pdf',
      '.doc': 'application/msword',
      '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      '.xls': 'application/vnd.ms-excel',
      '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      '.txt': 'text/plain',
      '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg',
      '.png': 'image/png',
      '.gif': 'image/gif',
      '.zip': 'application/zip',
      '.rar': 'application/x-rar-compressed'
    };
    return mimeTypes[ext] || 'application/octet-stream';
  }

  /**
   * Generate assessment based on scan results
   */
  generateAssessment(scanResult) {
    if (scanResult.threats.length > 0) {
      return 'MALICIOUS';
    } else if (scanResult.warnings.length > 0) {
      return 'SUSPICIOUS';
    } else {
      return 'CLEAN';
    }
  }

  /**
   * Generate recommendation based on scan results
   */
  generateRecommendation(scanResult) {
    if (scanResult.threats.length > 0) {
      return 'REJECT_FILE';
    } else if (scanResult.warnings.length > 0) {
      return 'REVIEW_MANUALLY';
    } else {
      return 'ACCEPT_FILE';
    }
  }

  /**
   * Generate scan report
   */
  generateScanReport(scanResults) {
    return {
      scanTime: new Date().toISOString(),
      totalFiles: scanResults.length,
      cleanFiles: scanResults.filter(r => r.isClean).length,
      maliciousFiles: scanResults.filter(r => !r.isClean).length,
      threats: scanResults.flatMap(r => r.threats),
      warnings: scanResults.flatMap(r => r.warnings),
      summary: {
        clean: scanResults.filter(r => r.isClean).length,
        suspicious: scanResults.filter(r => r.warnings.length > 0 && r.isClean).length,
        malicious: scanResults.filter(r => r.threats.length > 0).length
      }
    };
  }
}

// Create singleton instance
const malwareScanner = new MalwareScanner();

module.exports = malwareScanner;
